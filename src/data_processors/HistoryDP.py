# coding=utf-8
import copy
from utils import utils
import numpy as np
import logging
import pandas as pd
from tqdm import tqdm
import torch
from collections import defaultdict
from data_processors.DataProcessor import DataProcessor
from utils.global_p import *




class HistoryDP(DataProcessor):
    # keys of required feature info in data dict, need to be converted into tensor
    data_columns = [UID, IID, X, C_HISTORY, C_HISTORY_NEG]
    info_columns = [SAMPLE_ID, TIME, C_HISTORY_LENGTH, C_HISTORY_NEG_LENGTH]  # key of extra info in data dict

    @staticmethod
    def parse_dp_args(parser):
        """
        command parameters for data processor
        :param parser:
        :return:
        """
        # Some of these args are used by data_loader.append_his(all_his, max_his, neg_his, neg_column)
        parser.add_argument('--all_his', type=int, default=0,
                            help='Append all history in the training set')
        parser.add_argument('--max_his', type=int, default=-1,
                            help='Max history length. All his if max_his <= 0')
        parser.add_argument('--neg_his', type=int, default=0,
                            help='Whether keep negative interactions in the history')
        parser.add_argument('--neg_his_neg', type=int, default=0,
                            help='Whether keep negative interactions in the history as negative iid.')
        parser.add_argument('--neg_column', type=int, default=0,
                            help='Whether keep negative interactions in the history as a single column')
        parser.add_argument('--sparse_his', type=int, default=0,
                            help='Whether use sparse representation of user history.')
        parser.add_argument('--sup_his', type=int, default=0,
                            help='If sup_his > 0, supplement history list with 0')
        parser.add_argument('--drop_first', type=int, default=1,
                            help='If drop_first > 0, drop the first user interacted item with no previous history')
        return DataProcessor.parse_dp_args(parser)

    def __init__(self, max_his, sup_his, sparse_his, drop_first, *args, **kwargs):
        self.max_his = max_his
        self.sparse_his = sparse_his
        self.sup_his = sup_his
        self.drop_first = drop_first
        DataProcessor.__init__(self, *args, **kwargs)

    def get_feed_dict(self, data, batch_start, batch_size, train, neg_data=None, special_cols=None):
        """
        topn model generate a batch, if train, assign a negative sample for each positive sample, make sure first half is positive and second half is negative
        :param data: data dict，generated by self.get_*_data() and self.format_data_dict()
        :param batch_start: batch start index
        :param batch_size: batch size
        :param train: train or evaluation
        :param neg_data: data dict for negative samples，directly use it if exists
        :param special_cols: columns which need special operations
        :return: feed dict of the batch
        """
        feed_dict = DataProcessor.get_feed_dict(
            self, data, batch_start, batch_size, train, neg_data=neg_data,
            special_cols=[C_HISTORY, C_HISTORY_NEG]
            if special_cols is None else [C_HISTORY, C_HISTORY_NEG] + special_cols)
        his_cs, his_ls = [C_HISTORY], [C_HISTORY_LENGTH]
        if C_HISTORY_NEG in feed_dict:  # if exist negative history column
            his_cs.append(C_HISTORY_NEG)
            his_ls.append(C_HISTORY_NEG_LENGTH)

        for i, c in enumerate(his_cs):
            lc, d = his_ls[i], feed_dict[c]
            if self.sparse_his == 1:  # if sparse
                x, y, v = [], [], []
                for idx, iids in enumerate(d):
                    x.extend([idx] * len(iids))
                    y.extend([abs(iid) for iid in iids])
                    v.extend([1.0 if iid > 0 else -1.0 if iid < 0 else 0 for iid in iids])
                if len(x) <= 0:
                    i = utils.numpy_to_torch(np.array([[0], [0]]), gpu=False)
                    v = utils.numpy_to_torch(np.array([0.0], dtype=np.float32), gpu=False)
                else:
                    i = utils.numpy_to_torch(np.array([x, y]), gpu=False)
                    v = utils.numpy_to_torch(np.array(v, dtype=np.float32), gpu=False)
                history = torch.sparse.FloatTensor(
                    i, v, torch.Size([len(d), self.data_loader.item_num]))
                # if torch.cuda.device_count() > 0:
                #     history = history.cuda()
                feed_dict[c] = history
                feed_dict[lc] = [len(iids) for iids in d]
                # feed_dict[lc] = utils.numpy_to_torch(np.array([len(iids) for iids in d]), gpu=False)
            else:
                lengths = [len(iids) for iids in d]
                max_length = max(lengths)
                new_d = np.array([x + [0] * (max_length - len(x)) for x in d])
                feed_dict[c] = utils.numpy_to_torch(new_d, gpu=False)
                feed_dict[lc] = lengths
                # feed_dict[lc] = utils.numpy_to_torch(np.array(lengths), gpu=False)
        return feed_dict

    def format_data_dict(self, df, model):
        """
        deal with history interaction except uid,iid,label,user、item、context features
        :param df: train、validation、test df
        :param model: Model class
        :return:
        """
        assert C_HISTORY in df  # history should be in df

        his_cs = [C_HISTORY]
        if C_HISTORY_NEG in df:  # if exist negative history col
            his_cs.append(C_HISTORY_NEG)
        if self.drop_first == 1:
            for c in his_cs:
                df = df[df[c].apply(lambda x: len(x) > 0)]
        data_dict = DataProcessor.format_data_dict(self, df, model)

        for c in his_cs:
            his = df[c].apply(lambda x: eval('[' + x + ']'))
            # if self.max_his > 0:
            #     his = his.apply(lambda x: x[:self.max_his])
            #     if self.sup_his == 1:
            #         his = his.apply(lambda x: x + [0] * (self.max_his - len(x)))
            data_dict[c] = his.values
        return data_dict
